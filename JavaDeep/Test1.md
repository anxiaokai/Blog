## JVM CMS 算法
CMS（Concurrent Mark Sweep）是JVM中的一种并发标记清除算法，主要的目的是使得在清除垃圾对象时，尽可能的使应用程序停顿的时间最短。

它只是一个算法，算法的实现体现在CMS收集器上，它的工作过程可以分为四步：
>1. 初始标记（CMS initial mark）

标记GC Root可以直接关联到的对象。检测一个对象是不是已经不再被引用，有两种方法，一个是在对象被引用的时候一个变量加一，一旦取消了被别的对象的引用，则减去一。最后如果该变量为0，则证明该对象可以回收了。
第二种检测方法是从GC Root一路找下去，我理解应该就像是搜索树，只要是树上的节点，就证明该对象还在使用，否则就可以回收了。
所以，第一步就是找到和GC Root直接相连的子节点，凭感觉就可以知道，这一步的时间很短，所以这一步是阻塞的，会停止应用的运行。
>2. 并发标记（CMS concurrent mark）

第二步并发标记是沿着这个树，标记所有的节点。是所有的节点，时间肯定比较长，所以这个步骤是和应用程序并发执行的。
>3. 重新标记（CMS remark）

为啥要重新标记？我理解的是第二步骤之后，有的节点被标记了，但是之后又被使用了，所以在清除之前再确认一下。这一步是阻塞的。
>4. 并发清除（CMS concurrent sweep）

最后就是清除了，这一步也是并发的。

**问题**
该算法不就是为了让停顿时间最短吗？为啥不都弄成并发？那不就没有停顿了吗？

可能是并发会占用计算机的资源，该算法是想在尽可能不多消耗计算机资源的情况下，使停顿时间最短。

为啥使用标记-清除算法？
因为老年代的对象存活时间长，无用对象的比例低，复制，移动类的算法影响效率。

## G1算法
不划分代，而是把堆内存分成块，然后对其进行标记清除。清楚后把清除区域的存活对象拷贝到新区域。
解决了CMS碎片化严重的问题。

## 线程池
线程池就是多个已经创建好的线程放在一种数据结构中存储，使用的时候直接得到其中的一个线程使用，用完后再放回去，而不需要重新创建或者销毁线程。
线程用完了怎么办？好像是任务会放到队列中！
应用场景：频繁大量的使用线程的时候。

## 对象池
和线程池的本质上不多，对于创建和销毁非常耗费资源的对象，可以通过使用对象池，在程序初始化的时候就把它们创建出来，使用的时候直接使用就可以。另一个用处是限制某个对象的数目。

## 设计模式
工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式
适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式
策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

## 原子性，可见性，有序性
**原子性**：就是不可以分割，是作为一个整体来运行的，要不就都执行，要不就都不执行，也就是cpu不会再中间产生中断。
**可见性**：就是一个线程改变了一个变量的值，另一个线程可以看到。A线程改变了变量a的值，B线程可以得到a的最新值。
不论普通变量还是volatile修饰的变量，内部都是把改变后的变量值写入主内存中，然后另一个线程从住内存中获取最新值这个原理来实现可见性的。只是volatile修饰的变量值更改后会立即刷新到主内存中。
**有序性**：程序指令的执行顺序问题（不清晰）

## 强弱软虚引用
强引用：类似Apple apple=new Apple（）中的apple就是强引用，强引用一般不会被回收，即使内存空间不足的情况下。
软引用：一旦内存空间不够，就会被回收。
弱引用：不论此时内存空间是否够用，一旦gc扫描到了弱应用，它就会被回收。
虚引用：不论在任何时候都有可能被回收的引用，可以用来判断什么时候所引用的对象被回收。

## JNI VS JNA
JNI速度快，使用繁琐
JNA速度慢，使用简单
JNI申请的内存不归JVM管理

## JVM参数
java -Xmx3550m -Xms3550m -Xmn2g -Xss128k
-Xmx3550m：设置JVM最大可用内存为3550M。
-Xms3550m：设置JVM促使内存为3550m。
-Xmn2g：设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。
-Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。

